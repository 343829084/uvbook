

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>进程 &mdash; An Introduction to libuv</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="An Introduction to libuv" href="index.html" />
    <link rel="next" title="多路事件循环(Multiple event loops)" href="multiple.html" />
    <link rel="prev" title="线程" href="threads.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33699076-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>An Introduction to libuv</span></a></h1>
        <h2 class="heading"><span>进程</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="threads.html">线程</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="multiple.html">多路事件循环(Multiple event loops)</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>进程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>libuv offers considerable child process management, abstracting the platform
differences and allowing communication with the child process using streams or
named pipes.</p>
<p>A common idiom in Unix is for every process to do one thing and do it well. In
such a case, a process often uses multiple child processes to achieve tasks
(similar to using pipes in shells). A multi-process model with messages
may also be easier to reason about compared to one with threads and shared
memory.</p>
<p>A common refrain against event-based programs is that they cannot take
advantage of multiple cores in modern computers. In a multi-threaded program
the kernel can perform scheduling and assign different threads to different
cores, improving performance. But an event loop has only one thread.  The
workaround can be to launch multiple processes instead, with each process
running an event loop, and each process getting assigned to a separate CPU
core.</p>
<div class="section" id="spawning-child-processes">
<h2>创建子进程(Spawning child processes)<a class="headerlink" href="#spawning-child-processes" title="Permalink to this headline">¶</a></h2>
<p>The simplest case is when you simply want to launch a process and know when it
exits. This is achieved using <tt class="docutils literal"><span class="pre">uv_spawn</span></tt>.</p>
<p class="rubric">spawn/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_process_t</span> <span class="n">child_req</span><span class="p">;</span>
<span class="n">uv_process_options_t</span> <span class="n">options</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;mkdir&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;test-dir&quot;</span><span class="p">;</span>
<span class="hll">    <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span>
<span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
</span><span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="s">&quot;mkdir&quot;</span><span class="p">;</span>
</span><span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">uv_process_t</span></tt> struct only acts as the watcher, all options are set via
<tt class="docutils literal"><span class="pre">uv_process_options_t</span></tt>. To simply launch a process, you need to set only the
<tt class="docutils literal"><span class="pre">file</span></tt> and <tt class="docutils literal"><span class="pre">args</span></tt> fields. <tt class="docutils literal"><span class="pre">file</span></tt> is the program to execute. Since
<tt class="docutils literal"><span class="pre">uv_spawn</span></tt> uses <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man3/exec.3.html">execvp</a> internally, there is no need to supply the full
path. Finally as per underlying conventions, <strong>the arguments array has to be
one larger than the number of arguments, with the last element being NULL</strong>.</p>
<p>After the call to <tt class="docutils literal"><span class="pre">uv_spawn</span></tt>, <tt class="docutils literal"><span class="pre">uv_process_t.pid</span></tt> will contain the process
ID of the child process.</p>
<p>The exit callback will be invoked with the <em>exit status</em> and the type of <em>signal</em>
which caused the exit.</p>
<p class="rubric">spawn/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">on_exit</span><span class="p">(</span><span class="n">uv_process_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exit_status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">term_signal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Process exited with status %d, signal %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">exit_status</span><span class="p">,</span> <span class="n">term_signal</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>It is <strong>required</strong> to close the process watcher after the process exits.</p>
</div>
<div class="section" id="changing-process-parameters">
<h2>改变进程参数(Changing process parameters)<a class="headerlink" href="#changing-process-parameters" title="Permalink to this headline">¶</a></h2>
<p>Before the child process is launched you can control the execution environment
using fields in <tt class="docutils literal"><span class="pre">uv_process_options_t</span></tt>.</p>
<div class="section" id="change-execution-directory">
<h3>改变执行目录(Change execution directory)<a class="headerlink" href="#change-execution-directory" title="Permalink to this headline">¶</a></h3>
<p>设置 <tt class="docutils literal"><span class="pre">uv_process_options_t.cwd</span></tt> 参数改变进程的执行路径.</p>
</div>
<div class="section" id="set-environment-variables">
<h3>设置环境变量(Set environment variables)<a class="headerlink" href="#set-environment-variables" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">uv_process_options_t.env</span></tt> is an array of strings, each of the form
<tt class="docutils literal"><span class="pre">VAR=VALUE</span></tt> used to set up the environment variables for the process. Set
this to <tt class="docutils literal"><span class="pre">NULL</span></tt> to inherit the environment from the parent (this) process.</p>
</div>
<div class="section" id="option-flags">
<h3>选项参数(Option flags)<a class="headerlink" href="#option-flags" title="Permalink to this headline">¶</a></h3>
<p>Setting <tt class="docutils literal"><span class="pre">uv_process_options_t.flags</span></tt> to a bitwise OR of the following flags,
modifies the child process behaviour:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">UV_PROCESS_SETUID</span></tt> - sets the child&#8217;s execution user ID to <tt class="docutils literal"><span class="pre">uv_process_options_t.uid</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">UV_PROCESS_SETGID</span></tt> - sets the child&#8217;s execution group ID to <tt class="docutils literal"><span class="pre">uv_process_options_t.gid</span></tt>.</li>
</ul>
<p>Changing the UID/GID is only supported on Unix, <tt class="docutils literal"><span class="pre">uv_spawn</span></tt> will fail on
Windows with <tt class="docutils literal"><span class="pre">UV_ENOTSUP</span></tt>.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS</span></tt> - No quoting or escaping of
<tt class="docutils literal"><span class="pre">uv_process_options_t.args</span></tt> is done on Windows. Ignored on Unix.</li>
<li><tt class="docutils literal"><span class="pre">UV_PROCESS_DETACHED</span></tt> - Starts the child process in a new session, which
will keep running after the parent process exits. See example below.</li>
</ul>
</div>
</div>
<div class="section" id="detaching-processes">
<h2>进程分离(Detaching processes)<a class="headerlink" href="#detaching-processes" title="Permalink to this headline">¶</a></h2>
<p>Passing the flag <tt class="docutils literal"><span class="pre">UV_PROCESS_DETACHED</span></tt> can be used to launch daemons, or
child processes which are independent of the parent so that the parent exiting
does not affect it.</p>
<p class="rubric">detach/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;sleep&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;100&quot;</span><span class="p">;</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="s">&quot;sleep&quot;</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>
<span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_PROCESS_DETACHED</span><span class="p">;</span>
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Launched sleep with PID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">child_req</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_unref</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">);</span>
</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Just remember that the watcher is still monitoring the child, so your program
won&#8217;t exit. Use <tt class="docutils literal"><span class="pre">uv_unref()</span></tt> if you want to be more <em>fire-and-forget</em>.</p>
</div>
<div class="section" id="sending-signals-to-processes">
<h2>向进程发送信号(Sending signals to processes)<a class="headerlink" href="#sending-signals-to-processes" title="Permalink to this headline">¶</a></h2>
<p>libuv wraps the standard <tt class="docutils literal"><span class="pre">kill(2)</span></tt> system call on Unix and implements one
with similar semantics on Windows, with <em>one caveat</em>: all of <tt class="docutils literal"><span class="pre">SIGTERM</span></tt>,
<tt class="docutils literal"><span class="pre">SIGINT</span></tt> and <tt class="docutils literal"><span class="pre">SIGKILL</span></tt>, lead to termination of the process. The signature
of <tt class="docutils literal"><span class="pre">uv_kill</span></tt> is:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">uv_err_t</span> <span class="n">uv_kill</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signum</span><span class="p">);</span>
</pre></div>
</div>
<p>For processes started using libuv, you may use <tt class="docutils literal"><span class="pre">uv_process_kill</span></tt> instead,
which accepts the <tt class="docutils literal"><span class="pre">uv_process_t</span></tt> watcher as the first argument, rather than
the pid. In this case, <strong>remember to call</strong> <tt class="docutils literal"><span class="pre">uv_close</span></tt> on the watcher.</p>
</div>
<div class="section" id="signals">
<h2>信号(Signals)<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h2>
<p>TODO: update based on <a class="reference external" href="https://github.com/joyent/libuv/issues/668">https://github.com/joyent/libuv/issues/668</a></p>
<p>libuv provides wrappers around Unix signals with <a class="reference external" href="https://github.com/joyent/libuv/blob/node-v0.9.4/include/uv.h#L1659">some Windows support</a> as well.</p>
<p>To make signals &#8216;play nice&#8217; with libuv, the API will deliver signals to <em>all
handlers on all running event loops</em>! Use <tt class="docutils literal"><span class="pre">uv_signal_init()</span></tt> to initialize
a handler and associate it with a loop. To listen for particular signals on
that handler, use <tt class="docutils literal"><span class="pre">uv_signal_start()</span></tt> with the handler function. Each handler
can only be associated with one signal number, with subsequent calls to
<tt class="docutils literal"><span class="pre">uv_signal_start()</span></tt> overwriting earlier associations. Use <tt class="docutils literal"><span class="pre">uv_signal_stop()</span></tt> to
stop watching. Here is a small example demonstrating the various possibilities:</p>
<p class="rubric">signal/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;uv.h&gt;</span>

<span class="kt">void</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="n">uv_signal_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Signal received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">signum</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_signal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class="p">}</span>

<span class="c1">// two signal handlers in one loop</span>
<span class="kt">void</span> <span class="nf">thread1_worker</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop1</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>

    <span class="n">uv_signal_t</span> <span class="n">sig1a</span><span class="p">,</span> <span class="n">sig1b</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig1a</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig1a</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>
</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig1b</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig1b</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="n">uv_run</span><span class="p">(</span><span class="n">loop1</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// two signal handlers, each in its own loop</span>
<span class="kt">void</span> <span class="nf">thread2_worker</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">userp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop2</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>
    <span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop3</span> <span class="o">=</span> <span class="n">uv_loop_new</span><span class="p">();</span>

    <span class="n">uv_signal_t</span> <span class="n">sig2</span><span class="p">;</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig2</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig2</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="n">uv_signal_t</span> <span class="n">sig3</span><span class="p">;</span>
    <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">loop3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig3</span><span class="p">);</span>
    <span class="n">uv_signal_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sig3</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">uv_run</span><span class="p">(</span><span class="n">loop2</span><span class="p">,</span> <span class="n">UV_RUN_NOWAIT</span><span class="p">)</span> <span class="o">||</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop3</span><span class="p">,</span> <span class="n">UV_RUN_NOWAIT</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;PID %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="n">uv_thread_t</span> <span class="n">thread1</span><span class="p">,</span> <span class="n">thread2</span><span class="p">;</span>

    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">,</span> <span class="n">thread1_worker</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">uv_thread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2</span><span class="p">,</span> <span class="n">thread2_worker</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread1</span><span class="p">);</span>
    <span class="n">uv_thread_join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Send <tt class="docutils literal"><span class="pre">SIGUSR1</span></tt> to the process, and you&#8217;ll find the handler being invoked
4 times, one for each <tt class="docutils literal"><span class="pre">uv_signal_t</span></tt>. The handler just stops each handle,
so that the program exits. This sort of dispatch to all handlers is very
useful. A server using multiple event loops could ensure that all data was
safely saved before termination, simply by every loop adding a watcher for
<tt class="docutils literal"><span class="pre">SIGINT</span></tt>.</p>
</div>
<div class="section" id="i-o">
<h2>子进程 I/O<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h2>
<p>A normal, newly spawned process has its own set of file descriptors, with 0,
1 and 2 being <tt class="docutils literal"><span class="pre">stdin</span></tt>, <tt class="docutils literal"><span class="pre">stdout</span></tt> and <tt class="docutils literal"><span class="pre">stderr</span></tt> respectively. Sometimes you
may want to share file descriptors with the child. For example, perhaps your
applications launches a sub-command and you want any errors to go in the log
file, but ignore <tt class="docutils literal"><span class="pre">stdout</span></tt>. For this you&#8217;d like to have <tt class="docutils literal"><span class="pre">stderr</span></tt> of the
child to be displayed. In this case, libuv supports <em>inheriting</em> file
descriptors. In this sample, we invoke the test program, which is:</p>
<p class="rubric">proc-streams/test.c</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;This is stderr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is stdout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The actual program <tt class="docutils literal"><span class="pre">proc-streams</span></tt> runs this while inheriting only <tt class="docutils literal"><span class="pre">stderr</span></tt>.
The file descriptors of the child process are set using the <tt class="docutils literal"><span class="pre">stdio</span></tt> field in
<tt class="docutils literal"><span class="pre">uv_process_options_t</span></tt>. First set the <tt class="docutils literal"><span class="pre">stdio_count</span></tt> field to the number of
file descriptors being set. <tt class="docutils literal"><span class="pre">uv_process_options_t.stdio</span></tt> is an array of
<tt class="docutils literal"><span class="pre">uv_stdio_container_t</span></tt>, which is:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">uv_stdio_container_s</span> <span class="p">{</span>
  <span class="n">uv_stdio_flags</span> <span class="n">flags</span><span class="p">;</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="n">uv_stream_t</span><span class="o">*</span> <span class="n">stream</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv_stdio_container_t</span><span class="p">;</span>
</pre></div>
</div>
<p>where flags can have several values. Use <tt class="docutils literal"><span class="pre">UV_IGNORE</span></tt> if it isn&#8217;t going to be
used. If the first three <tt class="docutils literal"><span class="pre">stdio</span></tt> fields are marked as <tt class="docutils literal"><span class="pre">UV_IGNORE</span></tt> they&#8217;ll
redirect to <tt class="docutils literal"><span class="pre">/dev/null</span></tt>.</p>
<p>Since we want to pass on an existing descriptor, we&#8217;ll use <tt class="docutils literal"><span class="pre">UV_INHERIT_FD</span></tt>.
Then we set the <tt class="docutils literal"><span class="pre">fd</span></tt> to <tt class="docutils literal"><span class="pre">stderr</span></tt>.</p>
<p class="rubric">proc-streams/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="cm">/* ... */</span>

<span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span>    <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
<span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_FD</span><span class="p">;</span>
</span><span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="hll">    <span class="n">options</span><span class="p">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>
</span>
    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>If you run <tt class="docutils literal"><span class="pre">proc-stream</span></tt> you&#8217;ll see that only the line &#8220;This is stderr&#8221; will
be displayed. Try marking <tt class="docutils literal"><span class="pre">stdout</span></tt> as being inherited and see the output.</p>
<p>It is dead simple to apply this redirection to streams.  By setting <tt class="docutils literal"><span class="pre">flags</span></tt>
to <tt class="docutils literal"><span class="pre">UV_INHERIT_STREAM</span></tt> and setting <tt class="docutils literal"><span class="pre">data.stream</span></tt> to the stream in the
parent process, the child process can treat that stream as standard I/O. This
can be used to implement something like <a class="reference external" href="http://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>.</p>
<p>A sample CGI script/executable is:</p>
<p class="rubric">cgi/tick.c</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;tick</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;BOOM!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The CGI server combines the concepts from this chapter and <a class="reference internal" href="networking.html"><em>网络</em></a> so
that every client is sent ten ticks after which that connection is closed.</p>
<p class="rubric">cgi/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="hll">        <span class="n">invoke_cgi_script</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
</span>    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Here we simply accept the TCP connection and pass on the socket (<em>stream</em>) to
<tt class="docutils literal"><span class="pre">invoke_cgi_script</span></tt>.</p>
<p class="rubric">cgi/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">invoke_cgi_script</span><span class="p">(</span><span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">client</span><span class="p">)</span> <span class="p">{</span>

    <span class="cm">/* ... finding the executable path and setting up arguments ... */</span>

    <span class="n">options</span><span class="p">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
<span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_STREAM</span><span class="p">;</span>
</span><span class="hll">    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>
</span>    <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>

    <span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

<span class="hll">    <span class="n">child_req</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_req</span><span class="p">,</span> <span class="n">options</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">stdout</span></tt> of the CGI script is set to the socket so that whatever our tick
script prints, gets sent to the client. By using processes, we can offload the
read/write buffering to the operating system, so in terms of convenience this
is great. Just be warned that creating processes is a costly task.</p>
</div>
<div class="section" id="pipes">
<span id="id2"></span><h2>管道(Pipes)<a class="headerlink" href="#pipes" title="Permalink to this headline">¶</a></h2>
<p>libuv&#8217;s <tt class="docutils literal"><span class="pre">uv_pipe_t</span></tt> structure is slightly confusing to Unix programmers,
because it immediately conjures up <tt class="docutils literal"><span class="pre">|</span></tt> and <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man7/pipe.7.html">pipe(7)</a>. But <tt class="docutils literal"><span class="pre">uv_pipe_t</span></tt> is
not related to anonymous pipes, rather it has two uses:</p>
<ol class="arabic simple">
<li>Stream API - It acts as the concrete implementation of the <tt class="docutils literal"><span class="pre">uv_stream_t</span></tt>
API for providing a FIFO, streaming interface to local file I/O. This is
performed using <tt class="docutils literal"><span class="pre">uv_pipe_open</span></tt> as covered in <a class="reference internal" href="filesystem.html#buffers-and-streams"><em>缓冲区与流(Buffers and Streams)</em></a>.
You could also use it for TCP/UDP, but there are already convenience functions
and structures for them.</li>
<li>IPC mechanism - <tt class="docutils literal"><span class="pre">uv_pipe_t</span></tt> can be backed by a <a class="reference external" href="http://www.kernel.org/doc/man-pages/online/pages/man7/unix.7.html">Unix Domain Socket</a> or
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa365590(v=vs.85).aspx">Windows Named Pipe</a> to allow multiple processes to communicate. This is
discussed below.</li>
</ol>
<div class="section" id="id3">
<h3>父子进程间通信<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>A parent and child can have one or two way communication over a pipe created by
settings <tt class="docutils literal"><span class="pre">uv_stdio_container_t.flags</span></tt> to a bit-wise combination of
<tt class="docutils literal"><span class="pre">UV_CREATE_PIPE</span></tt> and <tt class="docutils literal"><span class="pre">UV_READABLE_PIPE</span></tt> or <tt class="docutils literal"><span class="pre">UV_WRITABLE_PIPE</span></tt>. The
read/write flag is from the perspective of the child process.</p>
</div>
<div class="section" id="id4">
<h3>任意进程间通信<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Since domain sockets <a class="footnote-reference" href="#id6" id="id5">[1]</a> can have a well known name and a location in the
file-system they can be used for IPC between unrelated processes. The <a class="reference external" href="http://www.freedesktop.org/wiki/Software/dbus">D-BUS</a>
system used by open source desktop environments uses domain sockets for event
notification. Various applications can then react when a contact comes online
or new hardware is detected. The MySQL server also runs a domain socket on
which clients can interact with it.</p>
<p>When using domain sockets, a client-server pattern is usually followed with the
creator/owner of the socket acting as the server. After the initial setup,
messaging is no different from TCP, so we&#8217;ll re-use the echo server example.</p>
<p class="rubric">pipe-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="n">uv_pipe_t</span> <span class="n">server</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">remove_sock</span><span class="p">);</span>

<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_pipe_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="s">&quot;echo.sock&quot;</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Bind error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Listen error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">uv_last_error</span><span class="p">(</span><span class="n">loop</span><span class="p">)));</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>We name the socket <tt class="docutils literal"><span class="pre">echo.sock</span></tt> which means it will be created in the local
directory. This socket now behaves no different from TCP sockets as far as
the stream API is concerned. You can test this server using <a class="reference external" href="http://netcat.sf.net">netcat</a>:</p>
<div class="highlight-c"><pre>$ nc -U /path/to/echo.sock</pre>
</div>
<p>A client which wants to connect to a domain socket will use:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="n">uv_pipe_connect</span><span class="p">(</span><span class="n">uv_connect_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">uv_connect_cb</span> <span class="n">cb</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">name</span></tt> will be <tt class="docutils literal"><span class="pre">echo.sock</span></tt> or similar.</p>
</div>
<div class="section" id="sending-file-descriptors-over-pipes">
<h3>通过管道发送文件描述符(Sending file descriptors over pipes)<a class="headerlink" href="#sending-file-descriptors-over-pipes" title="Permalink to this headline">¶</a></h3>
<p>The cool thing about domain sockets is that file descriptors can be exchanged
between processes by sending them over a domain socket. This allows processes
to hand off their I/O to other processes. Applications include load-balancing
servers, worker processes and other ways to make optimum use of CPU.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">On Windows, only file descriptors representing TCP sockets can be passed
around.</p>
</div>
<p>To demonstrate, we will look at a echo server implementation that hands of
clients to worker processes in a round-robin fashion. This program is a bit
involved, and while only snippets are included in the book, it is recommended
to read the full code to really understand it.</p>
<p>The worker process is quite simple, since the file-descriptor is handed over to
it by the master.</p>
<p class="rubric">multi-echo-server/worker.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_pipe_t</span> <span class="n">queue</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

<span class="hll">    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_pipe_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_read2_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">);</span>
</span>    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">queue</span></tt> is the pipe connected to the master process on the other end, along
which new file descriptors get sent. We use the <tt class="docutils literal"><span class="pre">read2</span></tt> function to express
interest in file descriptors. It is important to set the <tt class="docutils literal"><span class="pre">ipc</span></tt> argument of
<tt class="docutils literal"><span class="pre">uv_pipe_init</span></tt> to 1 to indicate this pipe will be used for inter-process
communication! Since the master will write the file handle to the standard
input of the worker, we connect the pipe to <tt class="docutils literal"><span class="pre">stdin</span></tt> using <tt class="docutils literal"><span class="pre">uv_pipe_open</span></tt>.</p>
<p class="rubric">multi-echo-server/worker.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="n">uv_buf_t</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uv_handle_type</span> <span class="n">pending</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pending</span> <span class="o">==</span> <span class="n">UV_UNKNOWN_HANDLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// error!</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_pipe_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_pipe_t</span><span class="p">));</span>
    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Worker %d: Accepted fd %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">client</span><span class="o">-&gt;</span><span class="n">io_watcher</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">uv_read_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">echo_read</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Although <tt class="docutils literal"><span class="pre">accept</span></tt> seems odd in this code, it actually makes sense. What
<tt class="docutils literal"><span class="pre">accept</span></tt> traditionally does is get a file descriptor (the client) from
another file descriptor (The listening socket). Which is exactly what we do
here. Fetch the file descriptor (<tt class="docutils literal"><span class="pre">client</span></tt>) from <tt class="docutils literal"><span class="pre">queue</span></tt>. From this point
the worker does standard echo server stuff.</p>
<p>Turning now to the master, let&#8217;s take a look at how the workers are launched to
allow load balancing.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">child_worker</span> <span class="p">{</span>
    <span class="n">uv_process_t</span> <span class="n">req</span><span class="p">;</span>
    <span class="n">uv_process_options_t</span> <span class="n">options</span><span class="p">;</span>
    <span class="n">uv_pipe_t</span> <span class="n">pipe</span><span class="p">;</span>
<span class="p">}</span> <span class="o">*</span><span class="n">workers</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">child_worker</span></tt> structure wraps the process, and the pipe between the
master and the individual process.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">setup_workers</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="c1">// launch same number of workers as number of CPUs</span>
    <span class="n">uv_cpu_info_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cpu_count</span><span class="p">;</span>
    <span class="n">uv_cpu_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpu_count</span><span class="p">);</span>
    <span class="n">uv_free_cpu_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cpu_count</span><span class="p">);</span>

    <span class="n">child_worker_count</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">;</span>

    <span class="n">workers</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">child_worker</span><span class="p">),</span> <span class="n">cpu_count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cpu_count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">child_worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">workers</span><span class="p">[</span><span class="n">cpu_count</span><span class="p">];</span>
<span class="hll">        <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span>
        <span class="n">uv_stdio_container_t</span> <span class="n">child_stdio</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="hll">        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_CREATE_PIPE</span> <span class="o">|</span> <span class="n">UV_READABLE_PIPE</span><span class="p">;</span>
</span><span class="hll">        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">stream</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">;</span>
</span>        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_IGNORE</span><span class="p">;</span>
        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UV_INHERIT_FD</span><span class="p">;</span>
        <span class="n">child_stdio</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">stdio</span> <span class="o">=</span> <span class="n">child_stdio</span><span class="p">;</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">stdio_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">exit_cb</span> <span class="o">=</span> <span class="n">on_exit</span><span class="p">;</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

        <span class="n">uv_spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">,</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">);</span> 
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Started worker %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">worker</span><span class="o">-&gt;</span><span class="n">req</span><span class="p">.</span><span class="n">pid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>In setting up the workers, we use the nifty libuv function <tt class="docutils literal"><span class="pre">uv_cpu_info</span></tt> to
get the number of CPUs so we can launch an equal number of workers. Again it is
important to initialize the pipe acting as the IPC channel with the third
argument as 1. We then indicate that the child process&#8217; <tt class="docutils literal"><span class="pre">stdin</span></tt> is to be
a readable pipe (from the point of view of the child). Everything is
straightforward till here. The workers are launched and waiting for file
descriptors to be written to their pipes.</p>
<p>It is in <tt class="docutils literal"><span class="pre">on_new_connection</span></tt> (the TCP infrastructure is initialized in
<tt class="docutils literal"><span class="pre">main()</span></tt>), that we accept the client socket and pass it along to the next
worker in the round-robin.</p>
<p class="rubric">multi-echo-server/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// error!</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">uv_pipe_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_pipe_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_pipe_t</span><span class="p">));</span>
    <span class="n">uv_pipe_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span>        <span class="n">uv_write_t</span> <span class="o">*</span><span class="n">write_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_write_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_write_t</span><span class="p">));</span>
        <span class="n">dummy_buf</span> <span class="o">=</span> <span class="n">uv_buf_init</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="hll">        <span class="k">struct</span> <span class="n">child_worker</span> <span class="o">*</span><span class="n">worker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">workers</span><span class="p">[</span><span class="n">round_robin_counter</span><span class="p">];</span>
</span><span class="hll">        <span class="n">uv_write2</span><span class="p">(</span><span class="n">write_req</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">worker</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span>        <span class="n">round_robin_counter</span> <span class="o">=</span> <span class="p">(</span><span class="n">round_robin_counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">child_worker_count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Again, the <tt class="docutils literal"><span class="pre">uv_write2</span></tt> call handles all the abstraction and it is simply
a matter of passing in the file descriptor as the right argument. With this our
multi-process echo server is operational.</p>
<p>TODO what do the write2/read2 functions do with the buffers?</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[1]</a></td><td>In this section domain sockets stands in for named pipes on Windows as
well.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="threads.html">线程</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="multiple.html">多路事件循环(Multiple event loops)</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, Nikhil Marathe.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>